\section{Détecteurs}

Dans le contexte de l'analyse d'images et de vidéos, il est souvent nécessaire
de détecter des points d'intérêt, par exemple des bords, des coins, etc.
C'est important pour des tâches d'appariement :
comparer les descripteurs de deux images et obtenir des correspondances,
estimer des transformations d'images (alignement),
faire du suivi dans des vidéos à partir de ces points d'intérêt,
et de l'odométrie visuelle pour estimer le mouvement de la caméra.

\subsection{Fonction d'intérêt d'Harris}

C'est ici qu'intervient la fonction (ou le détecteur) de Harris,
qui est idéal quand la rapidité et la stabilité sont nécessaires.
Cependant, lors de forts changements d'échelle, par exemple quand
un objet apparaît beaucoup plus grand ou plus petit
entre différents \emph{frames}, le détecteur de Harris est moins efficace.

La fonction d'intérêt de Harris se base sur le fait d'assigner une valeur à chaque pixel. Cette valeur mesure
à quel point ce pixel est une \emph{intersection}, c'est-à-dire un \emph{coin}.

Dire qu'un pixel est un coin signifie qu'on cherche à quel point il ressemble à l'intersection de deux bords.
Autrement dit, à quel point ce pixel correspond à un endroit où l'image change fortement dans deux directions
perpendiculaires. C'est utile, parce qu'avec une petite fenêtre de pixels (la fenêtre $W$), on peut estimer
à quel point ce qu'on observe change au niveau de la structure.

Intuitivement, si on déplace légèrement la fenêtre $W$ autour d'un pixel, on observe :
\begin{itemize}
    \item \textbf{Zone plane (sans texture)} : la fenêtre change très peu $\rightarrow$ ce n'est pas un coin.
    \item \textbf{Bord} : la fenêtre change peu en se déplaçant \emph{le long} du bord, mais change beaucoup 
    en le \emph{traversant}.
    \item \textbf{Coin} : la fenêtre change beaucoup dans presque n'importe quelle direction.
\end{itemize}

Ce que fait Harris, c'est utiliser les gradients $I_x$ et $I_y$ pour savoir à quel point l'intensité change
 selon $x$ et selon $y$.
Si autour du pixel il y a un changement fort dans une seule direction, on est plutôt sur un bord ; mais si 
les changements forts sont dans deux
directions, on parle d'un coin. Ainsi, $\Theta$, la réponse de Harris, est définie pixel par pixel : plus
$\Theta$ est grande, plus le pixel est un \emph{coin}.

Dans le détecteur de Harris, la fonction d'intérêt se définit comme :
$$
\Theta = R = \det(M) - k\,(\operatorname{trace}(M))^2
$$

Où $k$ est une valeur empirique de pénalisation : plus elle est grande, plus le critère est strict,
donc moins de coins sont détectés. $M$ est la matrice de structure obtenue à partir des gradients
$I_{x}$ et $I_{y}$, calculés après un lissage gaussien de l'image, avec le paramètre $\sigma$ qui contrôle
le niveau de lissage (réduction du bruit et des détails fins). La matrice $M$ se définit par :

$$
M(x,y)=
$$

$$
=\sum_{(u,v)\in W} w(u,v)
\begin{pmatrix}
I_x(u,v)^2 & I_x(u,v)I_y(u,v)\\
I_x(u,v)I_y(u,v) & I_y(u,v)^2
\end{pmatrix}
$$

Où $w(u,v)$ est une fonction de poids (pondération) qui donne plus d'importance aux pixels proches du centre
de la fenêtre $W$. Ainsi, la somme se fait sur une fenêtre autour du pixel analysé.

\begin{itemize}
  \item $I_x^2$ mesure à quel point l'image change dans la direction horizontale.
  \item $I_y^2$ mesure à quel point l'image change dans la direction verticale.
  \item $I_x I_y$ mesure la corrélation entre ces deux variations.
\end{itemize}

Et concernant les valeurs propres de $M$ : si les deux sont grandes, alors $R$ est grand et le pixel est un
\emph{coin}. Si l'une est grande et l'autre petite, alors $R$ devient négatif et le pixel correspond à un
\emph{bord}. Si les deux sont petites, alors $R$ est petit et le pixel est une zone plane.

Enfin, le déterminant de $M$ correspond au produit des valeurs propres, tandis que la trace correspond à leur
somme. Mais la trace ne distingue pas bien les bords des coins, c'est pour cela qu'on la pénalise (avec le
terme en $k$). La trace mesure surtout le changement global, alors que le déterminant met mieux en évidence
un vrai coin.

Par ailleurs, cette fonction d'intérêt est calculée à une seule échelle : on utilise un seul niveau de
lissage et une seule taille de fenêtre pour calculer $M$.

\subsection{Dilatation Morphologique}

Dans le traitement d'images, on cherche souvent à obtenir une valeur
représentative d'un voisinage.
Dans le cas de la dilatation morphologique, cette valeur correspond,
pour chaque pixel, au maximum dans ce voisinage.
Ce voisinage est défini par un élément structurant,
par exemple une fenêtre $3 \times 3$.

Dans le cas de Harris, cette dilatation morphologique est utilisée pour
détecter les maxima locaux puis faire la suppression des non-maxima.
Autrement dit, l'objectif est de garder les pics (les coins) les plus forts.

Dans le code de \texttt{Harris.py},
la variable \texttt{se} définit la fenêtre/le voisinage comme une matrice
de 1 de taille \texttt{d\_maxloc}, avec \texttt{d\_maxloc = 3} :

\begin{verbatim}
d_maxloc = 3
se = np.ones(
    (d_maxloc, d_maxloc), np.uint8
)
\end{verbatim}

Ensuite, l'instruction suivante fait que chaque pixel prend la valeur
la plus grande de sa fenêtre :

\begin{verbatim}
Theta_dil = cv2.dilate(Theta, se)
\end{verbatim}

Après, avec l'instruction suivante, on réalise une comparaison pixel
par pixel :

\begin{verbatim}
Theta_maxloc[Theta < Theta_dil] = 0.0
\end{verbatim}

Si la valeur originale est différente de la valeur dilatée, alors ce pixel
n'était pas un maximum local, donc sa valeur est supprimée (mise à zéro).
Dans le cas contraire, la valeur est conservée car c'est bien un maximum local.

Enfin, on applique un seuil relatif pour éliminer les maxima trop faibles :

\begin{verbatim}
Theta_maxloc[
    Theta < seuil_relatif * Theta.max()
] = 0.0
\end{verbatim}

\subsection{Résultats}

Le script \texttt{Harris.py} a été exécuté 50 fois avec \texttt{-stats}
sur l'image \texttt{Graffiti0.png}. Les mesures suivantes ont été obtenues.
Les résultats ci-dessous ont été mesurés avec les paramètres suivants :

\begin{verbatim}
SUM_WINDOW_SIZE = 5
HARRIS_K = 0.04
MAXLOC_NEIGHBORHOOD_SIZE = 3
RELATIVE_THRESHOLD = 0.01
\end{verbatim}

\begin{itemize}
    \item Dimension de l'image (niveau de gris) : $320 \times 400$.
    \item Type de l'image (niveau de gris) : \texttt{float64}.
    \item Dimension de l'image (couleur) : $320 \times 400 \times 3$.
    \item Type de l'image (couleur) : \texttt{uint8}.
\end{itemize}

\begin{table}[H]
    \centering
    \caption{Statistiques sur 50 exécutions du détecteur de Harris}
    \label{tab:harris_stats}
    \begin{tabular}{lc}
        \hline
        Métrique & Valeur \\
        \hline
        Temps moyen [s] & 0.003224673 \\
        Variance du temps [s$^2$] & 0.000002632168 \\
        Écart-type du temps [s] & 0.001622396 \\
        Cycles/pixel moyen [cpp] & 25.192756 \\
        Variance cycles/pixel [cpp$^2$] & 160.654768461 \\
        Écart-type cycles/pixel [cpp] & 12.674966 \\
        \hline
    \end{tabular}
\end{table}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{../../results/harris_points.png}
    \caption{Visualisation des points d'intérêt détectés par Harris sur \texttt{Graffiti0.png}.}
    \label{fig:harris_points}
\end{figure}

\subsection{Analyse Paramétrique du Détecteur de Harris}

Cette étude paramétrique a été réalisée avec la commande
\texttt{python Harris.py -stats 50 -plots}. L'échantillon correspond à
50 exécutions du calcul de Harris pour chaque valeur testée.
Pendant chaque balayage, les autres paramètres restent fixés à :
\texttt{SUM\_WINDOW\_SIZE = 5}, \texttt{HARRIS\_K = 0.04},
\texttt{MAXLOC\_NEIGHBORHOOD\_SIZE = 3},
\texttt{RELATIVE\_THRESHOLD = 0.01}.

\begin{figure}[H]
    \centering
    \begin{minipage}[t]{0.48\linewidth}
        \centering
        \includegraphics[width=\linewidth]{../../results/plots/harris/cpp_vs_sum_window_size.png}
        \vspace{2mm}
        \textbf{(a)} Cycles/pixel vs \texttt{SUM\_WINDOW\_SIZE}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.48\linewidth}
        \centering
        \includegraphics[width=\linewidth]{../../results/plots/harris/time_vs_sum_window_size.png}
        \vspace{2mm}
        \textbf{(b)} Temps moyen vs \texttt{SUM\_WINDOW\_SIZE}
    \end{minipage}
    \caption{Impact de \texttt{SUM\_WINDOW\_SIZE} sur le coût de calcul.}
    \label{fig:harris_sum_window_analysis}
\end{figure}

Quand \texttt{SUM\_WINDOW\_SIZE} augmente, le temps moyen et les cycles/pixel
augmentent nettement, car la convolution locale est plus coûteuse.
Du point de vue détection, une grande fenêtre stabilise la mesure de structure
(moins sensible au bruit), mais tend à lisser les détails fins et à réduire
le nombre de coins faibles détectés. À l'inverse, une petite fenêtre capte plus
de micro-variations (plus de coins potentiels), au prix d'une sensibilité plus forte
au bruit et donc d'un risque accru de faux positifs.

\begin{figure}[H]
    \centering
    \begin{minipage}[t]{0.48\linewidth}
        \centering
        \includegraphics[width=\linewidth]{../../results/plots/harris/cpp_vs_harris_k.png}
        \vspace{2mm}
        \textbf{(a)} Cycles/pixel vs \texttt{HARRIS\_K}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.48\linewidth}
        \centering
        \includegraphics[width=\linewidth]{../../results/plots/harris/time_vs_harris_k.png}
        \vspace{2mm}
        \textbf{(b)} Temps moyen vs \texttt{HARRIS\_K}
    \end{minipage}
    \caption{Impact de \texttt{HARRIS\_K} sur le coût de calcul.}
    \label{fig:harris_k_analysis}
\end{figure}

La variation de \texttt{HARRIS\_K} modifie peu le coût (même pipeline de calcul,
mêmes opérateurs principaux), ce qui est cohérent avec les courbes de temps/CPP.
En revanche, l'effet sur la sélection des coins est important :
un \texttt{HARRIS\_K} faible est plus permissif (plus de points retenus, y compris
des points ambigus proches des bords), tandis qu'un \texttt{HARRIS\_K} élevé
renforce la pénalisation de la trace, donc la sélection devient plus stricte
et le nombre de coins tend à diminuer, avec une meilleure stabilité géométrique.

\begin{figure}[H]
    \centering
    \begin{minipage}[t]{0.48\linewidth}
        \centering
        \includegraphics[width=\linewidth]{../../results/plots/harris/cpp_vs_maxloc_neighborhood_size.png}
        \vspace{2mm}
        \textbf{(a)} Cycles/pixel vs taille du voisinage NMS
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.48\linewidth}
        \centering
        \includegraphics[width=\linewidth]{../../results/plots/harris/time_vs_maxloc_neighborhood_size.png}
        \vspace{2mm}
        \textbf{(b)} Temps moyen vs taille du voisinage NMS
    \end{minipage}
    \caption{Impact de la taille du voisinage NMS sur le coût de calcul.}
    \label{fig:harris_maxloc_analysis}
\end{figure}

Quand \texttt{MAXLOC\_NEIGHBORHOOD\_SIZE} augmente, le coût augmente de manière
modérée, car la dilatation/non-max suppression parcourt un voisinage plus large.
Ce paramètre agit surtout sur la densité finale des points :
un voisinage grand rend la suppression non-maxima plus agressive
(moins de coins, mieux espacés, moins redondants), tandis qu'un voisinage petit
laisse passer plus de maxima locaux proches les uns des autres
(plus de coins, mais plus de redondance spatiale).

En synthèse, il existe un compromis classique entre sensibilité et robustesse :
augmenter la sensibilité aux détails produit souvent plus de coins, mais aussi
plus de bruit et de faux coins ; renforcer la robustesse réduit les faux positifs,
mais peut éliminer des coins faibles utiles pour certaines scènes.
Pour ce jeu d'images, la configuration de base
(\texttt{SUM\_WINDOW\_SIZE} = 5, \texttt{HARRIS\_K} = 0.04,
voisinage NMS = 3) reste un compromis raisonnable.

\subsection{Calcul de Harris sur Plusieurs Échelles}

Dans l'implémentation actuelle de \texttt{Harris.py}, le détecteur est
mono-échelle : on utilise un lissage gaussien fixe
(\texttt{sigma = 1.0}) ainsi qu'une fenêtre de sommation fixe pour construire
la matrice de structure.
Cette approche fonctionne bien pour une échelle donnée, mais elle perd en
robustesse lorsque la taille apparente des objets varie entre les images.

\textbf{Remarque.} Le paramètre \(\sigma\) représente le niveau de lissage
gaussien : plus \(\sigma\) est grand, plus le lissage est fort, et plus les
détails fins de l'image sont atténués (voire effacés).

Pour réaliser le calcul de Harris sur plusieurs échelles, on travaille dans
l'espace d'échelle \((x,y,\sigma)\) :
\begin{enumerate}
    \item Définir un ensemble d'échelles \(\sigma_1,\sigma_2,\dots,\sigma_n\)
    (ou construire une pyramide gaussienne).
    \item Pour chaque \(\sigma_i\), calculer \(I_x\), \(I_y\), la matrice
    \(M_{\sigma_i}\), puis la réponse de Harris \(R_{\sigma_i}\).
    \item Normaliser les réponses entre échelles pour les rendre comparables.
    \item Appliquer une suppression de non-maxima en 2D à chaque échelle,
    puis l'étendre en 3D :
    un point est conservé s'il est maximal dans son voisinage spatial et aussi
    par rapport à \(\sigma_{i-1}\), \(\sigma_i\) et \(\sigma_{i+1}\).
    \item Appliquer un seuil, puis reprojeter les points dans l'image originale
    en conservant leur échelle caractéristique.
\end{enumerate}

Les principaux compromis sont les suivants :
\begin{itemize}
    \item Plus d'échelles : meilleure robustesse aux changements de taille, mais
    coût de calcul plus élevé.
    \item Petites échelles : plus de détails et potentiellement plus de coins,
    mais aussi davantage de sensibilité au bruit.
    \item Grandes échelles : détection plus stable, mais risque de perdre des
    coins fins ou faibles.
\end{itemize}

Finalement, le lien avec la distance minimale \(r\) entre points d'intérêt est le suivant.
Pour garantir que deux points détectés restent séparés d'au moins \(r\) pixels,
on peut utiliser une suppression de non-maxima avec un rayon \(r\), ou une
ANMS (\emph{Adaptive Non-Maximum Suppression}).
Cela réduit la redondance spatiale et améliore la répartition des coins
dans l'image.

Au lieu d'utiliser un rayon fixe identique partout, l'ANMS attribue à chaque
coin candidat un rayon adaptatif \(r_i\), défini comme la distance au coin plus
fort le plus proche.
C'est-à-dire que
\begin{itemize}
    \item un coin très fort, isolé, obtient un grand rayon \(r_i\) ;
    \item un coin faible situé près d'un coin plus fort obtient un petit rayon.
\end{itemize}
Ensuite, on trie les candidats selon \(r_i\) et on conserve les points avec les
plus grands rayons.
On garde ainsi des coins à la fois fiables (bonne réponse Harris) et bien
répartis spatialement, ce qui est souvent préférable à une sélection locale
très dense dans une petite zone de l'image.
